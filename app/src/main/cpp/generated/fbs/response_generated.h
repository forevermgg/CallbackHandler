// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_RESPONSE_FIREBASE_REMOTE_CONFIG_FBS_H_
#define FLATBUFFERS_GENERATED_RESPONSE_FIREBASE_REMOTE_CONFIG_FBS_H_

#include "flatbuffers/flatbuffers.h"
#include "flatbuffers/flexbuffers.h"
#include "flatbuffers/flex_flat_util.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 5 &&
              FLATBUFFERS_VERSION_REVISION == 26,
             "Non-compatible flatbuffers version included");

namespace firebase {
namespace remote_config {
namespace fbs {

struct ErrorDetails;
struct ErrorDetailsBuilder;

struct Error;
struct ErrorBuilder;

struct Response;
struct ResponseBuilder;

struct ErrorDetails FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ErrorDetailsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_REASON = 4
  };
  const ::flatbuffers::String *reason() const {
    return GetPointer<const ::flatbuffers::String *>(VT_REASON);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_REASON) &&
           verifier.VerifyString(reason()) &&
           verifier.EndTable();
  }
};

struct ErrorDetailsBuilder {
  typedef ErrorDetails Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_reason(::flatbuffers::Offset<::flatbuffers::String> reason) {
    fbb_.AddOffset(ErrorDetails::VT_REASON, reason);
  }
  explicit ErrorDetailsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ErrorDetails> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ErrorDetails>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ErrorDetails> CreateErrorDetails(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> reason = 0) {
  ErrorDetailsBuilder builder_(_fbb);
  builder_.add_reason(reason);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ErrorDetails> CreateErrorDetailsDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *reason = nullptr) {
  auto reason__ = reason ? _fbb.CreateString(reason) : 0;
  return firebase::remote_config::fbs::CreateErrorDetails(
      _fbb,
      reason__);
}

struct Error FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ErrorBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CODE = 4,
    VT_MESSAGE = 6,
    VT_ERRORS = 8
  };
  int64_t code() const {
    return GetField<int64_t>(VT_CODE, 0);
  }
  const ::flatbuffers::String *message() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MESSAGE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<firebase::remote_config::fbs::ErrorDetails>> *errors() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<firebase::remote_config::fbs::ErrorDetails>> *>(VT_ERRORS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_CODE, 8) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           verifier.VerifyString(message()) &&
           VerifyOffset(verifier, VT_ERRORS) &&
           verifier.VerifyVector(errors()) &&
           verifier.VerifyVectorOfTables(errors()) &&
           verifier.EndTable();
  }
};

struct ErrorBuilder {
  typedef Error Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_code(int64_t code) {
    fbb_.AddElement<int64_t>(Error::VT_CODE, code, 0);
  }
  void add_message(::flatbuffers::Offset<::flatbuffers::String> message) {
    fbb_.AddOffset(Error::VT_MESSAGE, message);
  }
  void add_errors(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<firebase::remote_config::fbs::ErrorDetails>>> errors) {
    fbb_.AddOffset(Error::VT_ERRORS, errors);
  }
  explicit ErrorBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Error> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Error>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Error> CreateError(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t code = 0,
    ::flatbuffers::Offset<::flatbuffers::String> message = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<firebase::remote_config::fbs::ErrorDetails>>> errors = 0) {
  ErrorBuilder builder_(_fbb);
  builder_.add_code(code);
  builder_.add_errors(errors);
  builder_.add_message(message);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Error> CreateErrorDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t code = 0,
    const char *message = nullptr,
    const std::vector<::flatbuffers::Offset<firebase::remote_config::fbs::ErrorDetails>> *errors = nullptr) {
  auto message__ = message ? _fbb.CreateString(message) : 0;
  auto errors__ = errors ? _fbb.CreateVector<::flatbuffers::Offset<firebase::remote_config::fbs::ErrorDetails>>(*errors) : 0;
  return firebase::remote_config::fbs::CreateError(
      _fbb,
      code,
      message__,
      errors__);
}

struct Response FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ENTRIES = 4,
    VT_APPNAME = 6,
    VT_STATE = 8,
    VT_ERROR = 10
  };
  const ::flatbuffers::Vector<uint8_t> *entries() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_ENTRIES);
  }
  flexbuffers::Reference entries_flexbuffer_root() const {
    const auto _f = entries();
    return _f ? flexbuffers::GetRoot(_f->Data(), _f->size())
              : flexbuffers::Reference();
  }
  const ::flatbuffers::String *appName() const {
    return GetPointer<const ::flatbuffers::String *>(VT_APPNAME);
  }
  const ::flatbuffers::String *state() const {
    return GetPointer<const ::flatbuffers::String *>(VT_STATE);
  }
  const firebase::remote_config::fbs::Error *error() const {
    return GetPointer<const firebase::remote_config::fbs::Error *>(VT_ERROR);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ENTRIES) &&
           verifier.VerifyVector(entries()) &&
           flexbuffers::VerifyNestedFlexBuffer(entries(), verifier) &&
           VerifyOffset(verifier, VT_APPNAME) &&
           verifier.VerifyString(appName()) &&
           VerifyOffset(verifier, VT_STATE) &&
           verifier.VerifyString(state()) &&
           VerifyOffset(verifier, VT_ERROR) &&
           verifier.VerifyTable(error()) &&
           verifier.EndTable();
  }
};

struct ResponseBuilder {
  typedef Response Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_entries(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> entries) {
    fbb_.AddOffset(Response::VT_ENTRIES, entries);
  }
  void add_appName(::flatbuffers::Offset<::flatbuffers::String> appName) {
    fbb_.AddOffset(Response::VT_APPNAME, appName);
  }
  void add_state(::flatbuffers::Offset<::flatbuffers::String> state) {
    fbb_.AddOffset(Response::VT_STATE, state);
  }
  void add_error(::flatbuffers::Offset<firebase::remote_config::fbs::Error> error) {
    fbb_.AddOffset(Response::VT_ERROR, error);
  }
  explicit ResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Response> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Response>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Response> CreateResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> entries = 0,
    ::flatbuffers::Offset<::flatbuffers::String> appName = 0,
    ::flatbuffers::Offset<::flatbuffers::String> state = 0,
    ::flatbuffers::Offset<firebase::remote_config::fbs::Error> error = 0) {
  ResponseBuilder builder_(_fbb);
  builder_.add_error(error);
  builder_.add_state(state);
  builder_.add_appName(appName);
  builder_.add_entries(entries);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Response> CreateResponseDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *entries = nullptr,
    const char *appName = nullptr,
    const char *state = nullptr,
    ::flatbuffers::Offset<firebase::remote_config::fbs::Error> error = 0) {
  auto entries__ = entries ? _fbb.CreateVector<uint8_t>(*entries) : 0;
  auto appName__ = appName ? _fbb.CreateString(appName) : 0;
  auto state__ = state ? _fbb.CreateString(state) : 0;
  return firebase::remote_config::fbs::CreateResponse(
      _fbb,
      entries__,
      appName__,
      state__,
      error);
}

inline const firebase::remote_config::fbs::Response *GetResponse(const void *buf) {
  return ::flatbuffers::GetRoot<firebase::remote_config::fbs::Response>(buf);
}

inline const firebase::remote_config::fbs::Response *GetSizePrefixedResponse(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<firebase::remote_config::fbs::Response>(buf);
}

inline bool VerifyResponseBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<firebase::remote_config::fbs::Response>(nullptr);
}

inline bool VerifySizePrefixedResponseBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<firebase::remote_config::fbs::Response>(nullptr);
}

inline void FinishResponseBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<firebase::remote_config::fbs::Response> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedResponseBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<firebase::remote_config::fbs::Response> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace fbs
}  // namespace remote_config
}  // namespace firebase

#endif  // FLATBUFFERS_GENERATED_RESPONSE_FIREBASE_REMOTE_CONFIG_FBS_H_
